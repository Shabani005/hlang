#define NB_IMPLEMENTATION
#include "nb.h"

int main(int argc, char **argv){
  if (argc != 3){
    fprintf(stderr, "Usage: %s <input.hl> <executable-name>\n", argv[0]);
    return 1;
  }


  const char *hlc_native_src =
  "#include \"./bytecode.c\"\n"
  // "#define FG_IMPLEMENTATION\n"
  // "#include \"flag.h\"\n"
  "#include \"vm.h\"\n"
  "\n"
  "VM global_vm = {0};\n"
  "\n"
  "int main(int argc, char **argv) {\n"
  "    char* buf = malloc(sizeof(char*) * bytecode_count);\n"
  "\n"
  "    buf = nb_append_null(bytecode, bytecode_count);\n"
  "\n"
  "    Token tk = tokenize_all(buf);\n"
  "    SymbolTable table = {0};\n"
  "    symbol_table_init(&table, 32);\n"
  "\n"
  "    Token rpn = build_rpn(&tk, &table);\n"
  "\n"
  "    size_t prog_size = 0;\n"
  "    instruct *prog = rpn_to_bytecode(&rpn, &prog_size);\n"
  "\n"
  "    VM vm = {\n"
  "        .program = prog,\n"
  "        .program_size = prog_size,\n"
  "        .inst_p = 0,\n"
  "        .st_p = 0,\n"
  "        .running = true,\n"
  "    };\n"
  "    global_vm = vm;\n"
  "\n"
  "    vm_run(&vm);\n"
  "    return 0;\n"
  "}\n";
  
  nb_write_file("hlc-nativefile.c", (char *)hlc_native_src);

  const char *vm_h =
"#include \"parser.h\"\n"
"#include <string.h>\n"
"\n"
"typedef enum {\n"
"  OP_PUSH_INT,\n"
"  OP_PUSH_FLOAT,\n"
"  OP_PUSH_STRING,\n"
"  OP_ADD,\n"
"  OP_SUB,\n"
"  OP_MUL,\n"
"  OP_DIV,\n"
"  OP_PRINT,\n"
"  OP_HALT\n"
"} OPcode;\n"
"\n"
"typedef struct {\n"
"  OPcode op;\n"
"  double num;\n"
"  char *strlit;\n"
"} instruct;\n"
"\n"
"typedef enum {\n"
"    VAL_INT,\n"
"    VAL_FLOAT,\n"
"    VAL_STRING,\n"
"} ValueType;\n"
"\n"
"typedef struct {\n"
"    ValueType type;\n"
"    union {\n"
"        long i;\n"
"        double f;\n"
"        char *s;\n"
"    };\n"
"} Value;\n"
"\n"
"typedef struct {\n"
"  instruct *program;\n"
"  size_t inst_p;\n"
"  size_t program_size;\n"
"  Value stack[256];\n"
"  size_t st_p;\n"
"  bool running;\n"
"} VM;\n"
"\n"
"instruct *rpn_to_bytecode(Token *rpn, size_t *out){\n"
"  size_t cap = 64;\n"
"  size_t size = 0;\n"
"\n"
"  instruct *prog = malloc(sizeof(instruct) * cap);\n"
"\n"
"  for (size_t i=0; i<rpn->size; ++i){\n"
"    symbols t = rpn->type[i];\n"
"    const char *text = rpn->text[i];\n"
"\n"
"    instruct ins = {0};\n"
"\n"
"    switch (t){\n"
"      case TOKEN_INTEGER: ins.op = OP_PUSH_INT; ins.num = atof(text); break;\n"
"      case TOKEN_FLOAT: ins.op = OP_PUSH_FLOAT; ins.num = atof(text); break;\n"
"      case TOKEN_STRING: ins.op = OP_PUSH_STRING; ins.strlit = strdup(text); break;\n"
"      case TOKEN_PLUS: ins.op = OP_ADD; break;\n"
"      case TOKEN_MINUS: ins.op = OP_SUB; break;\n"
"      case TOKEN_MUL: ins.op = OP_MUL; break;\n"
"      case TOKEN_DIV: ins.op = OP_DIV; break;\n"
"\n"
"      case TOKEN_IDENTIFIER:\n"
"        if (strcmp(text, \"print\") == 0) {\n"
"            ins.op = OP_PRINT;\n"
"        } else {\n"
"            printf(\"[WARNING] Uknown Identifier '%s'\\n\", text);\n"
"        }\n"
"        break;\n"
"      case TOKEN_EOF: ins.op = OP_HALT; break;\n"
"      default: continue;\n"
"    }\n"
"    if (size >= cap){\n"
"      cap*=2;\n"
"      prog = realloc(prog, sizeof(instruct)*cap);\n"
"    }\n"
"    prog[size++] = ins;\n"
"  }\n"
"  *out = size;\n"
"  return prog;\n"
"}\n"
"\n"
"void vm_run(VM *vm) {\n"
"    vm->running = true;\n"
"    vm->inst_p = 0;\n"
"    vm->st_p = 0;\n"
"\n"
"    while (vm->running && vm->inst_p < vm->program_size) {\n"
"        instruct ins = vm->program[vm->inst_p++];\n"
"\n"
"        switch (ins.op) {\n"
"        case OP_PUSH_INT: {\n"
"            Value v = { .type = VAL_INT, .i = ins.num };\n"
"            vm->stack[vm->st_p++] = v;\n"
"        } break;\n"
"\n"
"        case OP_PUSH_FLOAT: {\n"
"            Value v = { .type = VAL_FLOAT, .f = ins.num };\n"
"            vm->stack[vm->st_p++] = v;\n"
"        } break;\n"
"\n"
"        case OP_PUSH_STRING: {\n"
"            Value v = { .type = VAL_STRING, .s = strdup(ins.strlit) };\n"
"            vm->stack[vm->st_p++] = v;\n"
"        } break;\n"
"\n"
"        case OP_ADD:\n"
"        case OP_SUB:\n"
"        case OP_MUL:\n"
"        case OP_DIV: {\n"
"            if (vm->st_p < 2) {\n"
"                fprintf(stderr, \"not enough values on stack.\\n\");\n"
"                vm->running = false;\n"
"                break;\n"
"            }\n"
"\n"
"            Value b = vm->stack[--vm->st_p];\n"
"            Value a = vm->stack[--vm->st_p];\n"
"\n"
"            double av = (a.type == VAL_INT) ? a.i : a.f;\n"
"            double bv = (b.type == VAL_INT) ? b.i : b.f;\n"
"            double result = 0;\n"
"\n"
"            switch (ins.op) {\n"
"            case OP_ADD: result = av + bv; break;\n"
"            case OP_SUB: result = av - bv; break;\n"
"            case OP_MUL: result = av * bv; break;\n"
"            case OP_DIV:\n"
"                if (bv == 0) {\n"
"                    fprintf(stderr, \"division by zero.\\n\");\n"
"                    vm->running = false;\n"
"                } else result = av / bv;\n"
"                break;\n"
"            default: break;\n"
"            }\n"
"\n"
"            Value v = { .type = VAL_FLOAT, .f = result };\n"
"            vm->stack[vm->st_p++] = v;\n"
"        } break;\n"
"\n"
"        case OP_PRINT: {\n"
"            if (vm->st_p == 0) {\n"
"                fprintf(stderr, \"cant print an empty stack\\n\");\n"
"                vm->running = false;\n"
"                break;\n"
"            }\n"
"\n"
"            Value v = vm->stack[--vm->st_p];\n"
"            switch (v.type) {\n"
"            case VAL_INT:   printf(\"%ld\\n\", v.i); break;\n"
"            case VAL_FLOAT: printf(\"%g\\n\", v.f); break;\n"
"            case VAL_STRING:\n"
"                printf(\"%s\\n\", v.s);\n"
"                free(v.s);\n"
"                break;\n"
"            }\n"
"        } break;\n"
"\n"
"        case OP_HALT:\n"
"            vm->running = false;\n"
"            break;\n"
"\n"
"        default:\n"
"            fprintf(stderr, \"unknown opcode %d\\n\", ins.op);\n"
"            vm->running = false;\n"
"            break;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"char *op_to_str(OPcode o){\n"
"  switch (o){  \n"
"  case OP_ADD: return \"OP_ADD\"; break;\n"
"  case OP_SUB: return \"OP_SUB\"; break;\n"
"  case OP_MUL: return \"OP_MUL\"; break;\n"
"  case OP_DIV: return \"OP_DIV\"; break;\n"
"  case OP_PRINT: return \"OP_PRINT\"; break;\n"
"  case OP_HALT: return \"OP_HALT\"; break;\n"
"  default: break;\n"
"    }\n"
"    return NULL;\n"
"}\n"
"\n"
"void emit_bytecode(VM *v){\n"
"    size_t i =0;\n"
"    while (i < v->program_size){\n"
"        if (v->program[i].op == OP_PUSH_INT) printf(\"OP_PUSH_INT(%f)\\n\", v->program[i].num);\n"
"        else if (v->program[i].op == OP_PUSH_FLOAT) printf(\"OP_PUSH_FLOAT(%f)\\n\", v->program[i].num);\n"
"        else if (v->program[i].op == OP_PUSH_STRING) printf(\"OP_PUSH_STRING(\\\"%s\\\")\\n\", v->program[i].strlit);\n"
"        else printf(\"%s\\n\", op_to_str(v->program[i].op));\n"
"        i++;\n"
"    }\n"
"    printf(\"\\n\");\n"
"}\n";

  
  nb_write_file("vm.h", (char *)vm_h);
  nb_xxd_info info = {0};
  char *buf = nb_xxd(argv[1], &info, "bytecode");
 
  nb_write_file("bytecode.c", buf);

  // nb_rebuild(argc, argv);
  
  nb_arr cmd = {0};

  nb_append(&cmd, "gcc");
  // nb_append(&cmd, "-Wall -Wextra");
  nb_append(&cmd, "-static");
  nb_append(&cmd, "./hlc-nativefile.c");
  nb_append_da(&cmd, "-o", argv[2]); // TODO: unhardcode
  nb_cmdq(&cmd); 

  nb_append_da(&cmd, "rm ./bytecode.c ./hlc-nativefile.c");
  nb_cmdq(&cmd);
  // nb_append_da(&cmd, "./native", argv[1]);
  // nb_cmdq(&cmd);
}
